READ ME : Projet Génération de codes
Author(s) : Antoine SOUESME & Sylvain BLANCHARD	

Lancement du programme : 
	- Run la classe Main.java


Main : 
	- La classe Main.java permet de : 
		lancer la génération des entités présentes dans le fichier model.xml
		lancer la génération de classe Repository.java


Fichier modèle : 
	
	- model.xml : contient le fichier d'entré pour l'association, l'héritage et le modèle de résolution.
	- paquet1.xml : contient le fichier plat d'entré pour le lot d'instances
	- repoModel.xml : contient le fichier pour la génération du fichier Repository.java

Contenu du projet : 
	
	- Main.java : classe principale du projet
	- MjPackage.java : classe correspondant a un package java
	- MjEntity.java : classe correspondant a une classe
	- MjAttribute.java : classe correspond a un attribut d'une classe
	- MjReference.java : classe correspondant a un type non primitif (exemple : un type d'une classe).
	- MjType.java : classe correspondant a la déclaration d'un type
	- RepositoryGenerator.java : classe servant à la génération d'un fichier repository en fonction d'un fichier model.
	- RepositoryTemp.java : resultat de la génération du repository
	- Util.java : classe contenant les outils pour récuperer l'ensemble des fonctions utiles à la génération de code.
	- Visiteur.java : classe pour la visite des différents objets du fichier xml à parser
	- xmlGenerator.java : classe pour générer un fichier xml
	
Choix de conception / etat d'avancement :


	Version minimale :
		Détection des entité et des attributs dans une classe fonctionnelles. Detection des objets lors du parsage du fichier xml d'entrée

	Association : 
		Les associations sont gérées de la manières suivantes : 
			Le mot clé "typedef" défini un nouveau type, il est composé de plusieurs elements : 
			un "id" unique, un "name", un "typeid" qui contient soit l'id d'un type défini auparavant soit un type primitif java. Il peut également posséder un element "length" s'il s'agit d'une liste bornée. Un element "package" est ajouter pour importer le package défini.

		Les listes d'objets avec cardinalités sont gérées de la manière suivante :
			avec une cardinalité fixe : un tableau est créé avec la taille de la cardinalité
			avec des cardinalités minimale et maximale : des fonctions add et remove permettant de conserver le nombre défini d'element dans la tableau.

		Globalement, sont gérées : 
			- liste d'élement primitif de base string,int ...
			- liste d'elmenent de type de données autres
		 	- liste d'entité (relation )
		 	- liste d'objet avec cardinalité fixe
		 	- liste d'objet avec cardinalité min et max

		L'ajout des attributs se faisant dans une hashmap défini avec des clé/valeurs, la clé représentant le nom de la variable, l'unicité des déclaration de variable est donc géré de cette manière.


	Heritage :
		L'héritage se fait en fonction dans la déclaration d'une nouvelle entité via le mot clé "extends". Si le mot clé est renseigner alors à la génération de l'entité on rajoute la classe qui est étendue. L'import du package dans laquelle se trouve la classe étendue est également gérée.
		L'héritage circulaire est géré.


	Valeur initiale :
		Les valeurs sont initialisées de la manière suivante :
		- S'il s'agit d'un type primitif (que l'element parsé contient une valeur "init"), la variable est initialisée à la valeur "init"
		- S'il s'agit d'un type object, l'object est instancié à l'aide d'un constructeur.


	Lot d'instance : (avoir le repo, serialisation + materialisation + génération du repo)
		"is" => classe fille
		"in" => classe mère 
		La classe RepositoryGenerator génère le repository. Cette classe Repository permet de générer un XML conforme aux lot d’instance décrit dans le fichier repoModel.xml. 



Reste à faire :


	- Terminer la génération du repository
	- re-bouclage



